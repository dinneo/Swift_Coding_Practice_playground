# 演算法與資料結構學習筆記

本書內容主要為筆者學習**Swift**程式語言與**演算法**/**資料結構**等主題的學習筆記。其中所載的演算法均以**Apple Inc.**所開發的**Xcode 7.3**與**Swift**程式語言作為實作演算法的程式語言。筆者將盡己所能隨著程式語言的版本更新而進行必要的維護。

如果您是一名資訊科學的學生或者是一個自學者，想要了解程式運作背後的理論，這資料將對您的學習有所幫助。筆者主要的目標為學習與知悉演算法的運作原理，並將實作與心得予以記載。主要專注在清晰可讀的程式碼實作，並不特別考量將來的直接利用性。雖然大部分的程式碼應該可直接使用於專案開發，建議您還是需要加以調整以更適於您開發中的專案。


## 前言:

### （一）什麼是演算法與資料結構?

演算法(Algorith)是讓電腦做一些事的配方或稱食譜。如果你知道怎麼烹調，你應該懂的演算法的意義！

下面是煎餅的[食譜](http://allrecipes.com/recipe/21014/good-old-fashioned-pancakes/):

1. 在一個大碗裡，混合均勻麵粉、泡打粉、鹽和糖。
2. 倒些牛奶、雞蛋和融化的奶油。
3. 混合直到柔滑。
4. 加熱煎鍋到中溫。
5. 將麵糊倒入鍋內，哪塊煎餅大約1/4杯的份量。
6. 持續煎熟煎餅直到兩側都呈棕黃色。

食譜包含一系列的步驟。演算法除了指令是提供給電腦執行的，而不是廚師外，其實就跟食譜是一樣的。

食譜中的材料 - 麵粉、牛奶、雞蛋、奶油 - 就如同演算法中的資料。該資料以某種形式(原始資料，獨立成分)進入算法，並以另一種形式呈現出來(美味的煎餅！)。

那麼，什麼是資料結構(Data Structures)？它們是保有資料的容器。在煎餅食譜的例子中，資料結構是麵粉袋、把材料攪拌混合均勻的碗以及煎鍋，最後是用來裝煎餅的煎餅袋。

### （二）為什麼要學演算法與資料結構?

如果您已經寫程式一段時間，您可能會開始思考何時該開始學習演算法與資料結構，尤其當您是一位沒有資訊科學背景的自學者時。

最後，您可能會問在攥寫一個應用時，會有多常使用一個串接或是自己寫的排序程序？答案是：幾乎沒有。

#### **然而...**

認識一些演算法的邏輯可以提供您改善自己程式的一些方向。認識更多的資料結構提供您更豐富的工具用以建構您的應用程式。這些都能讓你成為更好的程式設計師。

#### 當您遇到以下問題時，學習演算法可以幫助您

1. 當您被困在根本問題，已經無再去創造新的應用時。
2. 通常關乎應用的運行速度時。
3. 暴力演算法可以解決問題，但是當資料量更加龐大時您需要一個更聰明的演算法。
4. 有些時候您根本不知道如何解決城市中的一些問題時，懂一些演算法能提供您一些可嘗試的作法。

#### 不要花時間去記下一個演算法

花時間去記下一個演算法並不是一個好的作法，更應該去了解為什麼用某一個演算法去解決某一個問題。去學習一些技巧，諸如分治法(divide-and-conquer)、動態規劃(dynamic programming)與貪婪演算法(greedy algorithms)等等，並從中瞭解哪些演算法之所以快或慢的原因，使用上該如何取捨。關鍵在於我們想要電腦如何做事。

#### 演算法並沒有想像中可怕

許多的演算法教科書是從一大堆數學開始的。實際上數學是有用的，但大部分的時間您並不需要用到。所以無須害怕，如果您能寫程式，您也一定能學會資料結構與演算法。

相信我，演算法充滿了樂趣 :-)

### （三）**Big-O** 表示演算法效率的方式

要評斷一個演算法的好壞，最基本的指標是時間和空間。最直覺的方式，就是測量程式的執行時間、程式的記憶體使用量。但是由於相同演算法於不同電腦的執行時間會有差異，又由於每個人實作演算法所採用的程式語言、程式設計技巧不一，所以執行時間、記憶體使用量不是一個穩定的評斷標準。因此數學家採用大O表示法(**Big-O** notation)來表示演算法的時間與空間複雜度，用以衡量一個演算法之效率。

大O表示法(**Big-O**)提供一個演算法的運行時間和記憶體需求的粗略估計。當有人說，這種算法的最壞情況執行時間為**O(n²)**，以及使用的空間為**O(n)**，他們的意思是有點慢，但並不需要很多額外的記憶。

找出一種演算法的大O表示法(**Big-O**)通常是經由數學分析完成。此處，我們跳過了數學，僅提供一個方便的表。表中**n**是指你處理的數據中項的數量。例如，排序100個項目**n = 100**的陣列時。

****

 大O表示 | 類別 | 描述 
 ------| ---- | -----------
 **O(1)** | 常數 |**這是最好的** 無論資料大小，這種演算法的運算時間都是相同的。例如：以元素索引值查找陣列中的元素。
 **O(log n)** | 對數 | **非常優異** 這些種算法每次迭代伴隨數據量減半。如果你有100個項目，大約需要7個步驟來找到答案。若是1000的項目，它需要10個步驟。 1,000,000項目只需要20個步驟。對大量數據這類的方法超快速。例如：二元搜尋演算法(binary search)。 
 **O(n)** | 線性 | **優異效能** 如果你有100個項目，就是做100個工作單位。資料量倍增所需的時間隨之倍增。例如：依序查找演算法(sequential search)。 
 **O(n log n)** | 線性對數 | **不俗的表現.** 略差於線性的表現卻也不差。例如：最快的通用台續演算法。
 **O(n²)** | 二次方 | **緩慢**  如果你有100個項目，就是做10,000個工作單位。資料量倍增，時間需求四倍。例如：使用巢狀迴圈的插入排序演算法(insertion sort)。
 **O(n³)** | 三次方 | **相當慢** 如果你有100個項目，就是做1,000,000個工作單位。資料量倍增，時間需求八倍。 例如：矩陣相乘。
 **O(2ⁿ)** | 指數型 | **效率很差** 必須避免的演算法，但有時沒有選擇。只是增加一筆資料，需要的時間便加倍。例如：旅行行程規劃的問題。 
 **O(n!)** | 階乘型 | **難以忍受的緩慢** 非常的慢.

****

通常情況下你不需要用數學去找出一種演算法的大O表示法(**Big-O**)，可以簡單地運用你的直覺。如果你的程式碼使用一個循環，所處理數據量有**n**個元素，該算法是**O(n)**。如果代碼具有兩層巢狀迴圈(nested loops)，它是**O(n²)**。三層巢狀迴圈則為**O(n³)**，依此類推。

需要注意的是，大O表示法(**Big-O**)是一個估計值，僅對於**n**值很大時真的很有用。例如，插入排序演算法(insertion sort)之時間複雜度之最壞情況是**O(n²)**，從理論上講，插入排序演算法的效率應該比大O為**O(n log n)**的合併排序演算法(merge sort)差，但是對於少量數據，插入排序實際上要更快，尤其是當陣列部分已經排序好時！

如果你覺會受到混淆，不要讓這個大O干擾你太多。比較兩種算法時要弄清楚哪一個更好才是最有用的。最終你還是要在實踐中去檢驗哪一種演算法是最佳的。如果數據量是比較小的，那麼即使慢速算法亦將是在實際應用中足夠快的。

### （四）演算法設計技術

當你面對一個新問題的時候而你需要找到一個演算法，你該做什麼。

#### 它類似於另一個問題嗎？

如果你能以另一個更一般性的問題來描述您的問題，那麼您能夠使用現有的演算法，為什麼要推倒重來？

你可以試試由Steven Skiena所編撰的[算法設計手冊](http://www.algorist.com)，包含分類完整的許多問題及其解答。也可參見他的[算法庫](http://www3.cs.stonybrook.edu/~algorith/)。

#### 先從暴力解決方案開始是可行的

蠻力解決方案通常過於緩慢，但他們是一個好的起點。通過寫蠻力解決方案，你要學會真正地理解問題的所在。

一旦你實作出一個蠻力的解決方案，你可以用它來驗證後續拿出的改進是正確的。

如果你只是面對小量數據，那麼窮舉的辦法可能就已經夠好了。不要陷入過早優化的陷阱！

#### 分而治之

一個大問題往往只是一大堆小很多問題。


****
# 本文件取材自以下資料來源
* [演算法筆記](http://www.csie.ntnu.edu.tw/~u91029/Algorithm.html)
* [Swift Algorithm Club](https://github.com/hollance/swift-algorithm-club)

****



